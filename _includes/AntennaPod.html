<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyseur AntennaPod</title>
    <!-- Tailwind CSS is loaded globally -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- sql.js library for client-side SQLite processing - Moved to head for earlier loading -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.6.2/sql-wasm.js"></script>
    <style>
        /* Base styles for the app container */
        #antennapod-analyzer-app-container {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #2d3748; /* Darker text */
            padding: 6px; /* Added padding to ensure it doesn't touch the edges of the host page */
            overflow-x: hidden; /* Prevent horizontal scrolling on the main container */
        }
        /* All other CSS styles are now directly on class names, assuming they are unique enough
           or that the host page's CSS won't heavily conflict.
           This simplifies selectors and might resolve rendering issues. */
        #antennapod-analyzer-app-container .container { /* Re-scoped the container class */
            max-width: 1400px; /* Wider container for bento layout */
            margin: 40px auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 16px; /* More rounded */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); /* Stronger shadow */
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px; /* Spacing between cards */
        }
        /* Grid for main sections if needed, or keep as flow */
        @media (min-width: 768px) {
            #antennapod-analyzer-app-container .main-content-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Adjusted min width for better mobile fit */
                gap: 20px;
            }
            #antennapod-analyzer-app-container .full-width-card {
                grid-column: 1 / -1; /* Spans all columns */
            }
        }

        #antennapod-analyzer-app-container .card {
            background-color: #ffffff; /* White background for cards */
            border-radius: 12px; /* Consistent rounded corners */
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08); /* Subtle shadow */
            border: 1px solid #e2e8f0; /* Light border */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        #antennapod-analyzer-app-container .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
        }
        #antennapod-analyzer-app-container .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            border: 2px dashed #60a3ac; /* Lighter blue-green dashed border */
            border-radius: 10px;
            padding: 20px 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            background-color: #e6f2f3; /* Very light blue-green background */
        }
        #antennapod-analyzer-app-container .file-input-wrapper:hover, #antennapod-analyzer-app-container .file-input-wrapper.dragover {
            border-color: #0e6270;
            background-color: #d8e9eb;
        }
        #antennapod-analyzer-app-container .button {
            background-color: #0e6270; /* Primary blue-green */
            color: white;
            padding: 12px 25px;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            font-weight: 600;
        }
        #antennapod-analyzer-app-container .button:hover {
            background-color: #0a4c57; /* Darker blue-green */
            transform: translateY(-1px);
        }
        #antennapod-analyzer-app-container .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
            margin-top: 20px;
            min-height: 300px; /* Base minimum height */
        }
        #antennapod-analyzer-app-container #podcastEpisodeCountChart-container {
            min-height: auto;
        }

        #antennapod-analyzer-app-container .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 16px;
            z-index: 10;
        }
        #antennapod-analyzer-app-container .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #0e6270;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #antennapod-analyzer-app-container .message-box {
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            font-weight: bold;
            display: none;
            text-align: center;
        }
        #antennapod-analyzer-app-container .message-box.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        #antennapod-analyzer-app-container .message-box.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        #antennapod-analyzer-app-container .message-box.info {
            background-color: #e6f2f3;
            color: #0e6270;
            border: 1px solid #60a3ac;
        }
        #antennapod-analyzer-app-container textarea {
            width: 100%;
            height: 150px;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #cbd5e0;
            resize: vertical;
            background-color: #edf2f7;
            color: #2d3748;
            font-size: 0.95rem;
        }
        #antennapod-analyzer-app-container .podcast-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px 0;
        }
        #antennapod-analyzer-app-container .podcast-item img {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            margin-right: 12px;
            object-fit: cover;
            flex-shrink: 0;
        }
        #antennapod-analyzer-app-container #wrappedContent {
            padding: 25px;
            background-color: #e2e8f0;
            border-radius: 12px;
            margin-top: 15px;
            position: relative;
            text-align: center;
            font-family: 'Inter', sans-serif;
            color: #2d3748;
        }
        #antennapod-analyzer-app-container #wrappedContent h3 {
            color: #083e45;
            font-size: 1.6rem;
            margin-bottom: 15px;
            font-weight: 700;
        }
        #antennapod-analyzer-app-container #wrappedContent p {
            color: #4a5568;
            font-size: 1.05rem;
            line-height: 1.6;
            margin-bottom: 12px;
        }
        #antennapod-analyzer-app-container .wrapped-list {
            list-style: none;
            padding: 0;
            text-align: left;
            max-width: 90%;
            margin: 0 auto 20px auto;
        }
        #antennapod-analyzer-app-container .wrapped-list li {
            background-color: #ffffff;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            font-size: 0.95rem;
        }
        #antennapod-analyzer-app-container .wrapped-list li .icon {
            margin-right: 10px;
            font-size: 1.3em;
            color: #0e6270;
        }
        #antennapod-analyzer-app-container .export-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        #antennapod-analyzer-app-container .podcast-search-container {
            position: relative;
            width: 100%;
        }
        #antennapod-analyzer-app-container .podcast-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: #fff;
            border: 1px solid #cbd5e0;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        }
        #antennapod-analyzer-app-container .podcast-suggestion-item {
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #antennapod-analyzer-app-container .podcast-suggestion-item:hover,
        #antennapod-analyzer-app-container .podcast-suggestion-item.highlighted { /* Added highlighted class */
            background-color: #f0f4f8;
        }
        #antennapod-analyzer-app-container .search-clear-button {
            background-color: #e53e3e;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-left: 0; /* Changed for mobile */
            margin-top: 10px; /* Added for mobile */
            font-weight: 600;
            width: 100%; /* Full width on mobile */
        }
        @media (min-width: 768px) {
            #antennapod-analyzer-app-container .search-clear-button {
                margin-top: 0; /* Reset for desktop */
                margin-left: 10px; /* Reset for desktop */
                width: auto; /* Auto width on desktop */
            }
        }
        #antennapod-analyzer-app-container .filter-section {
            background-color: #f0f4f8;
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0;
        }
        #antennapod-analyzer-app-container .filter-section h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #083e45;
            margin-bottom: 20px;
            text-align: center;
        }
        #antennapod-analyzer-app-container .filter-group {
            display: flex;
            flex-direction: column; /* Stack vertically on mobile */
            align-items: flex-start; /* Align items to start on mobile */
            margin-bottom: 15px;
        }
        @media (min-width: 768px) {
            #antennapod-analyzer-app-container .filter-group {
                flex-direction: row; /* Back to row on larger screens */
                align-items: center; /* Center items on larger screens */
            }
        }
        #antennapod-analyzer-app-container .filter-group label {
            flex-shrink: 0;
            margin-right: 0; /* Remove right margin on mobile */
            margin-bottom: 8px; /* Add bottom margin on mobile */
            font-weight: 600;
            color: #4a5568;
            width: auto; /* Allow label to take auto width on mobile */
        }
        @media (min-width: 768px) {
            #antennapod-analyzer-app-container .filter-group label {
                margin-right: 15px; /* Restore right margin on larger screens */
                margin-bottom: 0; /* Remove bottom margin on larger screens */
                width: 150px; /* Restore fixed width on larger screens */
            }
        }
        #antennapod-analyzer-app-container .filter-group select, #antennapod-analyzer-app-container .filter-group input[type="text"], #antennapod-analyzer-app-container .filter-group input[type="date"] {
            flex-grow: 1;
            width: 100%; /* Make them take full width on mobile */
            padding: 10px 15px;
            border: 1px solid #cbd5e0;
            border-radius: 8px;
            background-color: #ffffff;
            color: #2d3748;
            font-size: 1rem;
        }
        #antennapod-analyzer-app-container .chart-period-info {
            text-align: center;
            font-size: 0.9rem;
            color: #0e6270;
            margin-bottom: 10px;
            font-weight: 500;
        }
        #antennapod-analyzer-app-container #topPodcastsTimeListFull, #antennapod-analyzer-app-container #monthlyPodcastListFull, #antennapod-analyzer-app-container #podcastStatsListFull {
            max-height: 300px;
            overflow-y: hidden;
            transition: max-height 0.5s ease-out;
        }
        #antennapod-analyzer-app-container #topPodcastsTimeListFull.expanded, #antennapod-analyzer-app-container #monthlyPodcastListFull.expanded, #antennapod-analyzer-app-container #podcastStatsListFull.expanded {
            max-height: 1000px;
            overflow-y: auto;
        }
        /* Styles for the new period navigation */
        #antennapod-analyzer-app-container .period-nav {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            background-color: #edf2f7; /* Light background for the nav bar */
            border-radius: 12px; /* Rounded corners for the bar */
            padding: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1); /* Inner shadow */
        }
        #antennapod-analyzer-app-container .period-nav button {
            flex: 1;
            padding: 10px 15px;
            border-radius: 8px; /* Rounded buttons */
            background-color: transparent;
            color: #4a5568; /* Default text color */
            font-weight: 600;
            transition: all 0.3s ease;
            border: none; /* No border for buttons */
            cursor: pointer;
        }
        #antennapod-analyzer-app-container .period-nav button.active {
            background-color: #0e6270; /* Active button background */
            color: white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); /* Shadow for active button */
            transform: translateY(-1px);
        }
        #antennapod-analyzer-app-container .period-nav button:not(.active):hover {
            background-color: #e2e8f0; /* Hover for inactive buttons */
            color: #0e6270;
        }

        /* Bento layout for key stats */
        #antennapod-analyzer-app-container .bento-key-stats-grid {
            display: grid;
            grid-template-columns: 1fr; /* Stack vertically on small screens */
            gap: 20px;
            grid-column: 1 / -1; /* Make this new grid span full width within main-content-grid */
        }

        @media (min-width: 768px) {
            #antennapod-analyzer-app-container .bento-key-stats-grid {
                grid-template-columns: repeat(3, 1fr); /* Three equal columns on desktop */
            }
            #antennapod-analyzer-app-container .overview-card {
                order: 1; /* Vue d'ensemble is leftmost */
                grid-column: span 1; /* It will take 1 column now */
            }
            #antennapod-analyzer-app-container .global-top-podcasts-card {
                order: 2; /* Global is in the center */
            }
            #antennapod-analyzer-app-container .period-top-podcasts-card {
                order: 3; /* Period is rightmost */
            }
        }
    </style>

    <div id="antennapod-analyzer-app-container">
        <div class="container">
            <h1 class="text-3xl font-bold text-center mb-6 text-gray-800">
                üéß Analyseur de Statistiques AntennaPod
            </h1>

            <div id="messageBox" class="message-box"></div>

            <div class="card mb-6">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">Uploader votre sauvegarde AntennaPod</h2>
                <p class="text-gray-600 mb-4">
                    <ol class="list-decimal ml-5 mb-4">
                        <li><strong>Cr√©er une sauvegarde dans AntennaPod</strong>
                            <ul class="list-disc ml-5 mt-2">
                                <li>Ouvrez AntennaPod et touchez l‚Äôic√¥ne ‚ò∞ (menu hamburger) en haut √† gauche.</li>
                                <li>Allez dans Pr√©f√©rences.</li>
                                <li>S√©lectionnez Importation / Exportation.</li>
                                <li>Touchez Exporter la base de donn√©es pour g√©n√©rer votre fichier de sauvegarde (AntennaPod.db).</li>
                                <li>Choisissez le dossier de destination sur votre appareil (stockage interne ou carte SD).</li>
                            </ul>
                        </li>
                        <li class="mt-4"><strong>Importer votre sauvegarde dans la web app</strong>
                            <p class="mt-2">Veuillez s√©lectionner le fichier de sauvegarde AntennaPod (AntennaPod.db) que vous venez d‚Äôexporter.</p>
                            <p>Vous le trouverez dans le dossier que vous avez choisi √† l‚Äô√©tape pr√©c√©dente.</p>
                        </li>
                    </ol>
                    <span class="text-sm text-red-500">Remarque : Les couvertures de vos podcasts seront affich√©es si elles sont accessibles en ligne. En cas d‚Äô√©chec de chargement, une illustration g√©n√©rique de remplacement sera utilis√©e.</span>
                </p>
                <div id="fileInputWrapper" class="flex flex-col items-center justify-center border-2 border-dashed border-gray-400 rounded-lg p-6 text-center bg-white hover:border-blue-400 transition-colors duration-200">
                    <label for="db-file-input" class="cursor-pointer">
                        <div class="flex flex-col items-center">
                            <svg class="w-12 h-12 text-gray-500 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                            <span class="text-lg text-gray-700 font-medium">D√©posez votre fichier ici ou cliquez pour uploader</span>
                            <span id="fileName" class="text-sm text-gray-500 mt-1">Aucun fichier s√©lectionn√©</span>
                        </div>
                    </label>
                    <input type="file" id="db-file-input" accept=".db" class="hidden" />
                </div>
                <button id="analyzeButton" class="button w-full mt-6 flex items-center justify-center" disabled>
                    <span id="analyzeButtonText">Analyser les statistiques</span>
                    <div id="loadingSpinner" class="spinner ml-3 hidden"></div>
                </button>
            </div>

            <div id="statsSection" class="hidden main-content-grid">
                <div class="card full-width-card filter-section">
                    <h2>Filtres de Donn√©es</h2>
                    <div class="filter-group">
                        <label for="startDateFilter">Date de d√©but&nbsp;:</label>
                        <input type="date" id="startDateFilter" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                    </div>
                    <div class="filter-group">
                        <label for="endDateFilter">Date de fin&nbsp;:</label>
                        <input type="date" id="endDateFilter" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                    </div>
                    <div class="filter-group">
                        <label for="podcastSearchInput">Rechercher un podcast&nbsp;:</label>
                        <div class="podcast-search-container">
                            <input type="text" id="podcastSearchInput" placeholder="Tapez le nom du podcast..." class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                            <div id="podcastSuggestions" class="podcast-suggestions hidden"></div>
                        </div>
                        <button id="clearPodcastSelection" class="search-clear-button">Effacer</button>
                        <input type="hidden" id="selectedPodcastHiddenInput"> <!-- To store the actual selected podcast title -->
                    </div>
                    <div class="filter-group">
                        <label for="tagFilter">S√©lectionnez un tag&nbsp;:</label>
                        <select id="tagFilter" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                            <option value="">Tous les tags</option>
                            <option value="Sans Tag">Sans Tag</option>
                        </select>
                    </div>
                    <div class="filter-group mt-4">
                        <label for="podcastDisplayLimitInput">Nombre de podcasts √† afficher&nbsp;:</label>
                        <input type="number" id="podcastDisplayLimitInput" value="10" min="1" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                    </div>
                </div>

                <!-- Bento layout for key stats -->
                <div class="bento-key-stats-grid">
                    <div class="card overview-card">
                        <h3 class="text-lg font-semibold mb-2 text-gray-700">Vue d'ensemble</h3>
                        <p><strong>üéß Temps total d'√©coute&nbsp;:</strong> <span id="totalListeningTime">0 heures</span></p>
                        <p><strong>üìª √âpisodes √©cout√©s&nbsp;:</strong> <span id="episodesListened">0</span></p>
                        <p><strong>‚úÖ √âpisodes termin√©s (>90%)&nbsp;:</strong> <span id="episodesCompleted">0 (0%)</span></p>
                        <p><strong>‚è±Ô∏è Dur√©e moyenne par √©coute&nbsp;:</strong> <span id="avgListenDuration">0 minutes</span></p>
                        <p><strong>üìä Progression moyenne&nbsp;:</strong> <span id="avgProgress">0%</span></p>
                    </div>

                    <div class="card global-top-podcasts-card">
                        <h3 class="text-lg font-semibold mb-2 text-gray-700">Top Podcasts par temps d'√©coute (global)</h3>
                        <ul id="topPodcastsTimeListShort" class="list-disc ml-5"></ul>
                        <div id="topPodcastsTimeListFull" class="hidden">
                            <ul id="topPodcastsTimeListAll" class="list-disc ml-5"></ul>
                        </div>
                        <button id="toggleTopPodcasts" class="button mt-4 text-sm px-4 py-2">Afficher plus</button>
                    </div>

                    <div id="monthlyPodcastDetail" class="card period-top-podcasts-card">
                        <h3 class="text-lg font-semibold mb-2 text-gray-700" id="monthlyPodcastDetailTitle">Top Podcasts pour la p√©riode</h3>
                        <ul id="monthlyPodcastListShort" class="ml-5"></ul>
                        <div id="monthlyPodcastListFull" class="hidden">
                            <ul id="monthlyPodcastListAll" class="ml-5"></ul>
                        </div>
                        <button id="toggleMonthlyPodcasts" class="button mt-4 text-sm px-4 py-2">Afficher plus</button>
                    </div>
                </div>

                <div class="card full-width-card">
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">√âcoutes par p√©riode</h3>
                    <!-- New Period Navigation -->
                    <div class="period-nav" id="periodNav">
                        <button id="viewMonthly" class="active">Mois</button>
                        <button id="viewWeekly">Semaine</button>
                        <button id="viewDaily">Jour</button>
                    </div>
                    <p id="monthlyChartPeriodInfo" class="chart-period-info"></p>
                    <div class="chart-container">
                        <canvas id="monthlyChart"></canvas>
                    </div>
                </div>

                <div class="card full-width-card">
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">Distribution du temps d'√©coute par Podcast</h3>
                    <p id="podcastTimeDistributionChartPeriodInfo" class="chart-period-info"></p>
                    <div class="chart-container">
                        <canvas id="podcastTimeDistributionChart"></canvas>
                    </div>
                </div>

                <!-- New Tag Distribution Chart -->
                <div class="card full-width-card">
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">Distribution du temps d'√©coute par Tag</h3>
                    <p class="text-sm text-gray-600 mb-2" id="tagInfoNote">
                        Note : Les tags sont extraits du nom de la cat√©gorie. L'application suppose qu'un tag commence par une majuscule et ne contient que des lettres (ex: "ScienceFiction" est interpr√©t√© comme "Science" et "Fiction"). Les podcasts sans tags sont regroup√©s sous la cat√©gorie "Sans Tag".
                    </p>
                    <div class="flex items-center mb-4">
                        <input type="checkbox" id="showSansTagCheckbox" checked class="mr-2">
                        <label for="showSansTagCheckbox" class="text-gray-700">Afficher 'Sans Tag'</label>
                    </div>
                    <p id="tagTimeDistributionChartPeriodInfo" class="chart-period-info"></p>
                    <div class="chart-container">
                        <canvas id="tagTimeDistributionChart"></canvas>
                    </div>
                </div>

                <div class="card full-width-card">
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">Statistiques par Podcast</h3>
                    <p id="podcastEpisodeCountChartPeriodInfo" class="chart-period-info"></p>
                    
                    <!-- Separated list and chart for Podcast Stats -->
                    <h4 class="font-medium text-gray-700 mt-4 mb-2">Top Podcasts par √©pisodes √©cout√©s (Liste)</h4>
                    <ul id="podcastStatsListShort" class="list-disc ml-5"></ul>
                    <div id="podcastStatsListFull" class="hidden">
                        <ul id="podcastStatsListAll" class="list-disc ml-5"></ul>
                    </div>
                    <button id="togglePodcastStats" class="button mt-4 text-sm px-4 py-2">Afficher plus</button>

                    <h4 class="font-medium text-gray-700 mt-6 mb-2">Top Podcasts par √©pisodes √©cout√©s (Graphique)</h4>
                    <div id="selectedPodcastStats" class="mt-4 hidden">
                        <h4 class="font-medium text-gray-700 mb-2">D√©tails pour&nbsp;: <span id="selectedPodcastTitleDisplay" class="font-semibold"></span></h4>
                        <p><strong>üéß Temps d'√©coute sur la p√©riode&nbsp;:</strong> <span id="selectedPodcastTime">0 heures</span></p>
                        <p><strong>üìª √âpisodes √©cout√©s sur la p√©riode&nbsp;:</strong> <span id="selectedPodcastEpisodes">0</span></p>
                    </div>
                    <div id="podcastEpisodeCountChart-container" class="chart-container">
                        <canvas id="podcastEpisodeCountChart"></canvas>
                    </div>
                </div>

                <div class="card full-width-card">
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">Habitudes d'√©coute</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <p id="hourlyChartPeriodInfo" class="chart-period-info"></p>
                            <h4 class="font-medium text-gray-700 mb-2">Temps d'√©coute par heure de la journ√©e</h4>
                            <div class="chart-container">
                                <canvas id="hourlyChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <p id="dailyChartPeriodInfo" class="chart-period-info"></p>
                            <h4 class="font-medium text-gray-700 mb-2">Temps d'√©coute par jour de la semaine</h4>
                            <div class="chart-container">
                                <canvas id="dailyChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="card full-width-card">
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">Export pour R√©seaux Sociaux (Inspir√© de Spotify Wrapped)</h3>
                    <div id="wrappedContent">
                        <p id="wrappedPeriodInfo" class="text-sm text-gray-600 mb-2"></p>
                        <div id="wrappedTextContent" class="text-gray-800 bg-gray-50 p-4 rounded-lg text-left whitespace-pre-wrap"></div>
                    </div>
                    <div class="export-buttons">
                        <button id="copyWrapped" class="button">Copier le texte Wrapped</button>
                        <button id="exportWrappedImage" class="button">Exporter l'image Wrapped</button>
                    </div>
                </div>

                <div class="card full-width-card">
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">Exporter tous les graphiques et donn√©es</h3>
                    <p class="text-gray-600 mb-4">
                        Cliquez sur les boutons ci-dessous pour exporter les donn√©es ou les graphiques.
                    </p>
                    <div class="export-buttons">
                        <button id="exportAllCharts" class="button">Exporter tous les graphiques (ZIP)</button>
                        <button id="exportCsvButton" class="button">Exporter les statistiques (CSV)</button>
                        <button id="exportRawDataCsvButton" class="button">Exporter les donn√©es brutes (CSV)</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Importation des modules Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // D√©finition des variables globales pour Firebase et l'application
        let db;
        let auth;
        let userId = 'anonymous'; // Default userId
        let app_id;
        let firebaseConfig;

        // Variables pour les graphiques Chart.js
        let monthlyChartInstance, podcastEpisodeCountChartInstance, hourlyChartInstance, dailyChartInstance, podcastTimeDistributionChartInstance, tagTimeDistributionChartInstance;
        let globalDfHistory = null; // Stocke les donn√©es de l'historique global
        let currentProcessedData = null; // Stores the currently processed (filtered) data for CSV export
        let allPodcastsTitles = []; // Global to store unique podcast titles for search suggestions
        let podcastDisplayLimit = 10; // Default display limit for top podcasts
        let podcastSearchSelectedIndex = -1; // For keyboard navigation in podcast search suggestions
        let currentPeriodView = 'month'; // New: Default view for "√âcoutes par p√©riode" chart


        // --- Firebase Initialization and Authentication ---
        const initializeFirebase = async () => {
            try {
                // Initialisation de l'application Firebase
                app_id = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Authentification
                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                // R√©cup√©ration de l'ID utilisateur apr√®s authentification
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log('Utilisateur authentifi√©:', userId);
                        // Vous pouvez d√©clencher le chargement des donn√©es utilisateur ici si n√©cessaire
                    } else {
                        console.log('Utilisateur d√©connect√© ou anonyme.');
                        userId = crypto.randomUUID(); // Fallback for anonymous users
                    }
                });

                console.log("Firebase initialis√©.");
            } catch (error) {
                console.error("Erreur lors de l'initialisation de Firebase:", error);
                showMessage('error', 'Erreur lors de la connexion aux services Firebase.');
            }
        };

        // Appel de l'initialisation Firebase au chargement de la page
        initializeFirebase();

        // --- DOM Elements ---
        const dbFileInput = document.getElementById('db-file-input');
        const fileNameSpan = document.getElementById('fileName');
        const analyzeButton = document.getElementById('analyzeButton');
        const analyzeButtonText = document.getElementById('analyzeButtonText');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const statsSection = document.getElementById('statsSection');
        const messageBox = document.getElementById('messageBox');
        const totalListeningTimeSpan = document.getElementById('totalListeningTime');
        const episodesListenedSpan = document.getElementById('episodesListened');
        const episodesCompletedSpan = document.getElementById('episodesCompleted'); 
        const avgListenDurationSpan = document.getElementById('avgListenDuration');
        const avgProgressSpan = document.getElementById('avgProgress');
        
        // Top Podcasts Drawer Elements
        const topPodcastsTimeListShort = document.getElementById('topPodcastsTimeListShort');
        const topPodcastsTimeListFull = document.getElementById('topPodcastsTimeListFull');
        const topPodcastsTimeListAll = document.getElementById('topPodcastsTimeListAll');
        const toggleTopPodcastsButton = document.getElementById('toggleTopPodcasts');

        const startDateFilter = document.getElementById('startDateFilter'); // New start date filter
        const endDateFilter = document.getElementById('endDateFilter');   // New end date filter
        const tagFilter = document.getElementById('tagFilter'); // New tag filter element
        const showSansTagCheckbox = document.getElementById('showSansTagCheckbox'); // New checkbox for 'Sans Tag'
        const monthlyPodcastDetail = document.getElementById('monthlyPodcastDetail');
        const monthlyPodcastDetailTitle = document.getElementById('monthlyPodcastDetailTitle');
        const monthlyPodcastListShort = document.getElementById('monthlyPodcastListShort'); // New for monthly drawer
        const monthlyPodcastListFull = document.getElementById('monthlyPodcastListFull'); // New for monthly drawer
        const monthlyPodcastListAll = document.getElementById('monthlyPodcastListAll'); // New for monthly drawer
        const toggleMonthlyPodcastsButton = document.getElementById('toggleMonthlyPodcasts'); // New for monthly drawer
        
        const podcastSearchInput = document.getElementById('podcastSearchInput');
        const podcastSuggestions = document.getElementById('podcastSuggestions');
        const selectedPodcastHiddenInput = document.getElementById('selectedPodcastHiddenInput');
        const clearPodcastSelectionButton = document.getElementById('clearPodcastSelection');
        const selectedPodcastStatsDiv = document.getElementById('selectedPodcastStats');
        const selectedPodcastTitleDisplay = document.getElementById('selectedPodcastTitleDisplay');
        const selectedPodcastTimeSpan = document.getElementById('selectedPodcastTime');
        const selectedPodcastEpisodesSpan = document.getElementById('selectedPodcastEpisodes');

        const podcastDisplayLimitInput = document.getElementById('podcastDisplayLimitInput'); // New input for limit

        const copyWrappedButton = document.getElementById('copyWrapped');
        const wrappedPeriodInfo = document.getElementById('wrappedPeriodInfo');
        const exportWrappedImageButton = document.getElementById('exportWrappedImage');
        const wrappedContentDiv = document.getElementById('wrappedContent');
        const wrappedTextContentDiv = document.getElementById('wrappedTextContent'); // New div for wrapped text

        const exportAllChartsButton = document.getElementById('exportAllCharts'); // New button for all charts export
        const exportCsvButton = document.getElementById('exportCsvButton'); // New button for CSV export
        const exportRawDataCsvButton = document.getElementById('exportRawDataCsvButton'); // New button for raw data CSV export

        // Chart Period Info Elements
        const monthlyChartPeriodInfo = document.getElementById('monthlyChartPeriodInfo');
        const podcastTimeDistributionChartPeriodInfo = document.getElementById('podcastTimeDistributionChartPeriodInfo');
        const tagTimeDistributionChartPeriodInfo = document.getElementById('tagTimeDistributionChartPeriodInfo'); // New for tags chart
        const podcastEpisodeCountChartPeriodInfo = document.getElementById('podcastEpisodeCountChartPeriodInfo');
        const hourlyChartPeriodInfo = document.getElementById('hourlyChartPeriodInfo');
        const dailyChartPeriodInfo = document.getElementById('dailyChartPeriodInfo');

        // Chart containers for dynamic height adjustment
        const podcastEpisodeCountChartContainer = document.getElementById('podcastEpisodeCountChart-container');

        // New elements for Podcast Stats List drawer
        const podcastStatsListShort = document.getElementById('podcastStatsListShort');
        const podcastStatsListFull = document.getElementById('podcastStatsListFull');
        const podcastStatsListAll = document.getElementById('podcastStatsListAll');
        const togglePodcastStatsButton = document.getElementById('togglePodcastStats');

        // Drag and Drop elements
        const fileInputWrapper = document.getElementById('fileInputWrapper');

        // New Period Navigation Elements
        const periodNav = document.getElementById('periodNav');
        const viewMonthlyButton = document.getElementById('viewMonthly');
        const viewWeeklyButton = document.getElementById('viewWeekly');
        const viewDailyButton = document.getElementById('viewDaily');


        // --- Chart Contexts ---
        const monthlyCtx = document.getElementById('monthlyChart').getContext('2d');
        const podcastEpisodeCountCtx = document.getElementById('podcastEpisodeCountChart').getContext('2d');
        const podcastTimeDistributionCtx = document.getElementById('podcastTimeDistributionChart').getContext('2d');
        const tagTimeDistributionCtx = document.getElementById('tagTimeDistributionChart').getContext('2d'); // New context for tags chart
        const hourlyCtx = document.getElementById('hourlyChart').getContext('2d');
        const dailyCtx = document.getElementById('dailyChart').getContext('2d');

        // --- Utility Functions ---

        // Function to display messages
        function showMessage(type, message) {
            messageBox.className = `message-box ${type}`;
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 5000); // Hide after 5 seconds
        }

        // Function to convert milliseconds to hours, minutes, seconds
        function msToHMS(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor((totalSeconds % 3600) / 60);
            const minutes = totalSeconds % 60;
            const seconds = totalSeconds % 60;
            return { hours, minutes, seconds };
        }

        /**
         * Attempts to fix common encoding issues (e.g., UTF-8 interpreted as Latin-1).
         * This specifically targets the "√É¬©" pattern for "√©".
         * @param {string} text The text string to fix.
         * @returns {string} The fixed string, or the original if fixing failed.
         */
        function fixEncoding(text) {
            if (typeof text !== 'string' || text === null) return text;

            let fixedText = text;
            // console.log("fixEncoding - Original:", text); // Debugging: original input

            // Attempt 1: Decode URI components, which can fix some UTF-8 misinterpreted as Latin-1
            try {
                const tempFixed = decodeURIComponent(escape(text));
                if (tempFixed !== text) {
                    fixedText = tempFixed;
                    // console.log(`fixEncoding - After decodeURIComponent: "${fixedText}"`); // Debugging
                }
            } catch (e) {
                console.warn("decodeURIComponent failed for:", text, e);
            }

            // Attempt 2: Direct replacements for common mojibake patterns
            // These are common patterns when UTF-8 bytes are read as ISO-8859-1 or Windows-1252
            fixedText = fixedText
                .replace(/√É¬©/g, '√©')
                .replace(/√É¬®/g, '√®')
                .replace(/√É /g, '√†')
                .replace(/√É¬™/g, '√™')
                .replace(/√É¬Æ/g, '√Æ')
                .replace(/√É¬¥/g, '√¥')
                .replace(/√É¬π/g, '√π')
                .replace(/√É¬ß/g, '√ß')
                .replace(/√É‚Ç¨/g, '√Ä')
                .replace(/√ÉÀÜ/g, '√à')
                .replace(/√É≈†/g, '√ä')
                .replace(/√É≈í/g, '√å')
                .replace(/√É‚Äù/g, '√î')
                .replace(/√É‚Ñ¢/g, '√ô')
                .replace(/√É‚Ä°/g, '√á')
                .replace(/√É¬´/g, '√´') // e tr√©ma
                .replace(/√É¬Ø/g, '√Ø') // i tr√©ma
                .replace(/√É¬º/g, '√º') // u tr√©ma
                .replace(/√É¬∂/g, '√∂') // o tr√©ma
                .replace(/√É¬§/g, '√§') // a tr√©ma
                .replace(/√¢‚Ç¨‚Ñ¢/g, '‚Äô') // apostrophe curly
                .replace(/√¢‚Ç¨≈ì/g, '‚Äú') // left double quote
                .replace(/√¢‚Ç¨¬ù/g, '‚Äù') // right double quote
                .replace(/√¢‚Ç¨¬¶/g, '‚Ä¶') // ellipsis
                .replace(/√¢‚Ç¨‚Äú/g, '‚Äì') // en dash
                .replace(/√¢‚Ç¨‚Äù/g, '‚Äî') // em dash
                .replace(/√¢‚Ç¨¬¢/g, '‚Ä¢'); // bullet

            // console.log("fixEncoding - Final:", fixedText); // Debugging: final output
            return fixedText;
        }

        /**
         * Calculates the ISO week number (YYYY-WW) for a given Date object.
         * @param {Date} d The date to calculate the ISO week for.
         * @returns {string} The ISO week string in "YYYY-WW" format.
         */
        function getISOWeek(d) {
            d = new Date(d.getTime()); // Create a copy to avoid modifying the original date
            d.setHours(0, 0, 0, 0); // Set to midnight UTC to avoid timezone issues
            // Thursday in current week decides the year.
            d.setDate(d.getDate() + 3 - (d.getDay() + 6) % 7);
            // January 4 is always in week 1.
            var week1 = new Date(d.getFullYear(), 0, 4);
            // Adjust to Sunday in week 1 and count number of weeks from date to week1.
            const weekNo = 1 + Math.round(((d.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
            return `${d.getFullYear()}-S${String(weekNo).padStart(2, '0')}`; // Changed 'W' to 'S'
        }


        // --- Event Listeners ---
        dbFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            handleFile(file);
        });

        // Drag and Drop Event Listeners
        fileInputWrapper.addEventListener('dragover', (event) => {
            event.preventDefault(); // Prevent default to allow drop
            fileInputWrapper.classList.add('dragover');
        });

        fileInputWrapper.addEventListener('dragleave', (event) => {
            fileInputWrapper.classList.remove('dragover');
        });

        fileInputWrapper.addEventListener('drop', (event) => {
            event.preventDefault(); // Prevent default to allow drop
            fileInputWrapper.classList.remove('dragover');
            const file = event.dataTransfer.files[0];
            if (file && file.name.endsWith('.db')) {
                dbFileInput.files = event.dataTransfer.files; // Set the file to the input element
                handleFile(file);
            } else {
                showMessage('error', 'Veuillez d√©poser un fichier .db valide.');
            }
        });

        function handleFile(file) {
            if (file) {
                fileNameSpan.textContent = file.name;
                analyzeButton.disabled = false;
                showMessage('info', `Fichier s√©lectionn√© : ${file.name}`);
            } else {
                fileNameSpan.textContent = 'Aucun fichier s√©lectionn√©';
                analyzeButton.disabled = true;
            }
        }

        analyzeButton.addEventListener('click', async () => {
            const file = dbFileInput.files[0];
            if (!file) {
                showMessage('error', 'Veuillez s√©lectionner un fichier .db d\'abord.');
                return;
            }

            setLoadingState(true);
            showMessage('info', 'Analyse en cours, cela peut prendre quelques instants...');

            try {
                // Read the file as an array buffer
                const arrayBuffer = await file.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);
                
                const processedData = await processAntennaPodDb(uint8Array);

                if (processedData) {
                    globalDfHistory = processedData.allHistoryData; // Store raw data for filters
                    currentProcessedData = processedData; // Store processed data for CSV export
                    updateUIWithStats(processedData);
                    populateFilters(processedData.allHistoryData);
                    updateCharts(); // Call updateCharts to draw with initial (all data) filters
                    statsSection.classList.remove('hidden');
                    showMessage('success', 'Analyse termin√©e avec succ√®s !');
                } else {
                    showMessage('error', '√âchec de l\'analyse du fichier. Le format pourrait √™tre invalide ou les donn√©es manquantes.');
                    statsSection.classList.add('hidden');
                }

            } catch (error) {
                console.error('Erreur lors de l\'analyse du fichier :', error);
                showMessage('error', `Une erreur est survenue lors de l'analyse : ${error.message}.`);
                statsSection.classList.add('hidden');
            } finally {
                setLoadingState(false);
            }
        });

        copyWrappedButton.addEventListener('click', async () => {
            const textToCopy = wrappedTextContentDiv.textContent;
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(textToCopy);
                    showMessage('success', 'Rapport copi√© dans le presse-papiers !');
                } else {
                    // Fallback for older browsers or environments without navigator.clipboard
                    const tempTextArea = document.createElement('textarea');
                    tempTextArea.value = textToCopy;
                    document.body.appendChild(tempTextArea); 
                    tempTextArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempTextArea); 
                    showMessage('success', 'Rapport copi√© dans le presse-papiers (via fallback) !');
                }
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showMessage('error', '√âchec de la copie du rapport.');
            }
        });

        exportWrappedImageButton.addEventListener('click', async () => {
            try {
                showMessage('info', 'G√©n√©ration de l\'image en cours...');
                
                // Ensure the content is visible and rendered before capturing
                wrappedContentDiv.style.display = 'block'; 
                
                const canvas = await html2canvas(wrappedContentDiv, { 
                    scale: 2, // Increase resolution for better quality
                    useCORS: true, // Needed if you have images from different origins (like placehold.co)
                    logging: false, // Disable logging if not debugging
                    backgroundColor: '#e2e8f0' // Ensure background is captured
                }); 
                
                // Convert canvas to image data URL
                const imageDataURL = canvas.toDataURL('image/png');
                
                // Create a temporary link element to trigger download
                const downloadLink = document.createElement('a');
                downloadLink.href = imageDataURL;
                downloadLink.download = 'AntennaPod_Wrapped_Report.png'; // File name
                document.body.appendChild(downloadLink); 
                downloadLink.click(); // Programmatically click the link to trigger download
                document.body.removeChild(downloadLink); 
                
                showMessage('success', 'Image export√©e avec succ√®s !');
            } catch (error) {
                console.error('Erreur lors de l\'exportation de l\'image :', error);
                showMessage('error', `Erreur lors de l'exportation de l'image : ${error.message}.`);
            }
        });

        // New: Export all charts as PNGs in a ZIP file
        exportAllChartsButton.addEventListener('click', async () => {
            showMessage('info', 'Pr√©paration de l\'exportation de tous les graphiques...');
            const zip = new JSZip();
            const chartsToExport = [
                { id: 'monthlyChart', name: 'Ecoutes_Mensuelles' },
                { id: 'podcastTimeDistributionChart', name: 'Distribution_Temps_Ecoute_Podcast' },
                { id: 'tagTimeDistributionChart', name: 'Distribution_Temps_Ecoute_Tag' }, // Added for tags chart
                { id: 'podcastEpisodeCountChart', name: 'Episodes_Ecoutes_Podcast' },
                { id: 'hourlyChart', name: 'Habitudes_Ecoute_Heure' },
                { id: 'dailyChart', name: 'Habitudes_Ecoute_Jour' }
            ];

            // Define padding for exported images
            const exportPadding = 20; // pixels

            for (const chartInfo of chartsToExport) {
                const canvasElement = document.getElementById(chartInfo.id); 
                if (canvasElement) {
                    try {
                        // Get the data URL directly from the Chart.js rendered canvas
                        const chartDataURL = canvasElement.toDataURL('image/png');

                        // Create a new canvas to draw the chart with padding
                        const tempCanvas = document.createElement('canvas');
                        const ctx = tempCanvas.getContext('2d');

                        const img = new Image();
                        img.src = chartDataURL;

                        // Wait for the image to load before drawing
                        await new Promise(resolve => {
                            img.onload = () => {
                                tempCanvas.width = img.width + 2 * exportPadding;
                                tempCanvas.height = img.height + 2 * exportPadding;
                                ctx.fillStyle = '#ffffff'; // White background for padding area
                                ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                                ctx.drawImage(img, exportPadding, exportPadding);
                                resolve();
                            };
                            img.onerror = (e) => {
                                console.error("Error loading image for padding:", e);
                                resolve(); // Resolve even on error to not block the loop
                            };
                        });

                        const paddedImageData = tempCanvas.toDataURL('image/png').split(',')[1];
                        zip.file(`${chartInfo.name}.png`, paddedImageData, { base64: true });

                    } catch (error) {
                        console.error(`Erreur lors de l'exportation du graphique ${chartInfo.name}:`, error);
                        showMessage('error', `Erreur lors de l'exportation du graphique ${chartInfo.name}.`);
                    }
                }
            }

            if (Object.keys(zip.files).length > 0) {
                zip.generateAsync({ type: "blob" })
                    .then(function (content) {
                        saveAs(content, "AntennaPod_Charts.zip");
                        showMessage('success', 'Tous les graphiques ont √©t√© export√©s dans un fichier ZIP !');
                    })
                    .catch(error => {
                        console.error('Erreur lors de la cr√©ation du fichier ZIP:', error);
                        showMessage('error', 'Erreur lors de la cr√©ation du fichier ZIP.');
                    });
            } else {
                showMessage('info', 'Aucun graphique √† exporter.');
            }
        });

        // New: Export statistics to CSV
        exportCsvButton.addEventListener('click', () => {
            if (!currentProcessedData) {
                showMessage('error', 'Aucune donn√©e √† exporter. Veuillez d\'abord analyser un fichier.');
                return;
            }
            exportStatsToCsv(currentProcessedData);
        });

        // New: Export raw data to CSV
        exportRawDataCsvButton.addEventListener('click', () => {
            if (!currentProcessedData || !currentProcessedData.allHistoryData || currentProcessedData.allHistoryData.length === 0) {
                showMessage('error', 'Aucune donn√©e brute √† exporter. Veuillez d\'abord analyser un fichier.');
                return;
            }
            exportRawDataToCsv(currentProcessedData.allHistoryData);
        });


        startDateFilter.addEventListener('change', updateCharts); // New event listener
        endDateFilter.addEventListener('change', updateCharts);   // New event listener
        tagFilter.addEventListener('change', updateCharts); // New event listener for tag filter
        showSansTagCheckbox.addEventListener('change', updateCharts); // New event listener for 'Sans Tag' checkbox
        
        // Podcast search input event listeners
        podcastSearchInput.addEventListener('input', filterPodcastSuggestions);
        podcastSearchInput.addEventListener('focus', () => {
            // Show all suggestions when input is focused and empty
            if (podcastSearchInput.value.length === 0) {
                filterPodcastSuggestions(); // This will now show all if search term is empty
            }
            podcastSuggestions.classList.remove('hidden');
        });
        podcastSearchInput.addEventListener('blur', () => {
             // Hide suggestions after a short delay to allow click events on suggestions to fire
            setTimeout(() => {
                podcastSuggestions.classList.add('hidden');
            }, 100);
        });

        // Keyboard navigation for podcast search suggestions
        podcastSearchInput.addEventListener('keydown', (event) => {
            const suggestions = Array.from(podcastSuggestions.children);
            if (suggestions.length === 0) return;

            if (event.key === 'ArrowDown') {
                event.preventDefault(); // Prevent cursor movement in input
                podcastSearchSelectedIndex = (podcastSearchSelectedIndex + 1) % suggestions.length;
                highlightSuggestion(suggestions);
            } else if (event.key === 'ArrowUp') {
                event.preventDefault(); // Prevent cursor movement in input
                podcastSearchSelectedIndex = (podcastSearchSelectedIndex - 1 + suggestions.length) % suggestions.length;
                highlightSuggestion(suggestions);
            } else if (event.key === 'Enter') {
                event.preventDefault(); // Prevent form submission
                if (podcastSearchSelectedIndex !== -1) {
                    const selectedPodcast = suggestions[podcastSearchSelectedIndex].textContent;
                    podcastSearchInput.value = selectedPodcast;
                    selectedPodcastHiddenInput.value = selectedPodcast;
                    podcastSuggestions.classList.add('hidden');
                    podcastSearchSelectedIndex = -1; // Reset index
                    updateCharts();
                }
            }
        });

        function highlightSuggestion(suggestions) {
            suggestions.forEach((item, index) => {
                if (index === podcastSearchSelectedIndex) {
                    item.classList.add('highlighted');
                    item.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); // Scroll to highlighted item smoothly
                } else {
                    item.classList.remove('highlighted');
                }
            });
        }


        clearPodcastSelectionButton.addEventListener('click', () => {
            podcastSearchInput.value = '';
            selectedPodcastHiddenInput.value = '';
            selectedPodcastStatsDiv.classList.add('hidden'); // Hide specific podcast stats
            updateCharts(); // Re-render charts with no podcast filter
        });

        // Add a click listener to the document to hide suggestions when clicking outside
        document.addEventListener('click', (event) => { 
            if (!podcastSuggestions.contains(event.target) && event.target !== podcastSearchInput) {
                podcastSuggestions.classList.add('hidden');
            }
        });

        // Toggle Top Podcasts Drawer (Global)
        toggleTopPodcastsButton.addEventListener('click', () => {
            const isExpanded = topPodcastsTimeListFull.classList.contains('expanded');
            // Toggle the expanded state
            if (isExpanded) {
                topPodcastsTimeListFull.classList.remove('expanded');
                topPodcastsTimeListFull.classList.add('hidden');
                topPodcastsTimeListShort.classList.remove('hidden'); // Show short list again
                toggleTopPodcastsButton.textContent = 'Afficher plus';
            } else {
                topPodcastsTimeListFull.classList.remove('hidden');
                topPodcastsTimeListFull.classList.add('expanded');
                topPodcastsTimeListShort.classList.add('hidden'); // Hide short list
                toggleTopPodcastsButton.textContent = 'Afficher moins';
            }
            // Re-render the short list based on the new expanded state
            renderTopPodcastsTimeList(currentProcessedData.topPodcastsByTime, !isExpanded);
        });

        // Toggle Monthly Podcasts Drawer
        toggleMonthlyPodcastsButton.addEventListener('click', () => {
            const isExpanded = monthlyPodcastListFull.classList.contains('expanded');
            if (isExpanded) {
                monthlyPodcastListFull.classList.remove('expanded');
                monthlyPodcastListFull.classList.add('hidden');
                monthlyPodcastListShort.classList.remove('hidden'); // Show short list again
                toggleMonthlyPodcastsButton.textContent = 'Afficher plus';
            } else {
                monthlyPodcastListFull.classList.remove('hidden');
                monthlyPodcastListFull.classList.add('expanded');
                monthlyPodcastListShort.classList.add('hidden'); // Hide short list
                toggleMonthlyPodcastsButton.textContent = 'Afficher moins';
            }
            // Re-render the short list based on the new expanded state
            updateMonthlyPodcastList(currentProcessedData.topPodcastsByTime, !isExpanded);
        });

        // Toggle Podcast Stats Drawer (New)
        togglePodcastStatsButton.addEventListener('click', () => {
            const isExpanded = podcastStatsListFull.classList.contains('expanded');
            // Toggle the expanded state
            if (isExpanded) {
                podcastStatsListFull.classList.remove('expanded');
                podcastStatsListFull.classList.add('hidden');
                podcastStatsListShort.classList.remove('hidden'); // Show short list again
                togglePodcastStatsButton.textContent = 'Afficher plus';
            } else {
                podcastStatsListFull.classList.remove('hidden');
                podcastStatsListFull.classList.add('expanded');
                podcastStatsListShort.classList.add('hidden'); // Hide short list
                togglePodcastStatsButton.textContent = 'Afficher moins';
            }
            // Re-render the short list based on the new expanded state
            renderPodcastStatsList(currentProcessedData.topPodcastsByEpisodeCount, !isExpanded);
        });


        // Update podcastDisplayLimit when input changes
        podcastDisplayLimitInput.addEventListener('change', () => {
            const newValue = parseInt(podcastDisplayLimitInput.value, 10);
            if (!isNaN(newValue) && newValue > 0) {
                podcastDisplayLimit = newValue;
                updateCharts(); // Re-render charts with the new limit
            } else {
                showMessage('error', 'Veuillez entrer un nombre valide (>0) pour la limite d\'affichage.');
                podcastDisplayLimitInput.value = podcastDisplayLimit; // Revert to last valid value
            }
        });

        // New: Event listeners for period navigation buttons
        viewMonthlyButton.addEventListener('click', () => {
            currentPeriodView = 'month';
            updatePeriodNavButtons();
            updateCharts();
        });
        viewWeeklyButton.addEventListener('click', () => {
            currentPeriodView = 'week';
            updatePeriodNavButtons();
            updateCharts();
        });
        viewDailyButton.addEventListener('click', () => {
            currentPeriodView = 'day';
            updatePeriodNavButtons();
            updateCharts();
        });

        function updatePeriodNavButtons() {
            viewMonthlyButton.classList.remove('active');
            viewWeeklyButton.classList.remove('active');
            viewDailyButton.classList.remove('active');

            if (currentPeriodView === 'month') {
                viewMonthlyButton.classList.add('active');
            } else if (currentPeriodView === 'week') {
                viewWeeklyButton.classList.add('active');
            } else if (currentPeriodView === 'day') {
                viewDailyButton.classList.add('active');
            }
        }


        // --- UI Update Functions ---
        function setLoadingState(isLoading) {
            analyzeButton.disabled = isLoading;
            dbFileInput.disabled = isLoading;
            if (isLoading) {
                analyzeButtonText.textContent = 'Analyse en cours...';
                loadingSpinner.classList.remove('hidden');
            } else {
                analyzeButtonText.textContent = 'Analyser les statistiques';
                loadingSpinner.classList.add('hidden');
            }
        }

        function updateUIWithStats(stats) {
            totalListeningTimeSpan.textContent = `${stats.totalListeningTimeHours.toFixed(1)} heures (${stats.totalListeningTimeDays.toFixed(1)} jours)`;
            episodesListenedSpan.textContent = stats.episodesListened;
            episodesCompletedSpan.textContent = `${stats.episodesCompleted} (${stats.completionRate.toFixed(1)}%)`;
            avgListenDurationSpan.textContent = `${stats.avgListenDurationMinutes.toFixed(1)} minutes`;
            avgProgressSpan.textContent = `${stats.avgProgressPercent.toFixed(1)}%`;

            // Initial render of Top Podcasts by Time (collapsed state)
            renderTopPodcastsTimeList(stats.topPodcastsByTime, false);
            updateMonthlyPodcastList(stats.topPodcastsByTime, false); // Initial render for monthly list
        }

        /**
         * Renders the Top Podcasts by Time list, handling "Autres" based on expanded state.
         * @param {Array} topPodcasts The full sorted list of top podcasts by time.
         * @param {boolean} isExpanded Whether the full list is currently expanded.
         */
        function renderTopPodcastsTimeList(topPodcasts, isExpanded) {
            topPodcastsTimeListShort.innerHTML = '';
            topPodcastsTimeListAll.innerHTML = '';

            const displayLimit = podcastDisplayLimit;

            if (isExpanded) {
                // If expanded, populate full list and hide short list
                topPodcasts.forEach((p, index) => {
                    const li = document.createElement('li');
                    li.className = 'podcast-item';
                    const img = document.createElement('img');
                    const defaultPlaceholder = `https://placehold.co/50x50/ADD8E6/000000?text=${p.podcast.substring(0,2).toUpperCase()}`;
                    if (p.imageUrl && (p.imageUrl.startsWith('http://') || p.imageUrl.startsWith('https://'))) {
                        img.src = p.imageUrl;
                        img.onerror = () => {
                            img.src = defaultPlaceholder;
                        };
                    } else {
                        img.src = defaultPlaceholder;
                    }
                    img.alt = `Couverture de ${p.podcast}`;
                    li.appendChild(img);
                    
                    const textSpan = document.createElement('span');
                    textSpan.textContent = `${index + 1}. ${p.podcast}: ${p.hours.toFixed(1)}h`;
                    li.appendChild(textSpan);
                    topPodcastsTimeListAll.appendChild(li);
                });
                topPodcastsTimeListShort.classList.add('hidden');
                topPodcastsTimeListFull.classList.remove('hidden');
            } else {
                // If collapsed, populate short list (with "Autres" if needed) and hide full list
                topPodcasts.slice(0, displayLimit).forEach((p, index) => {
                    const li = document.createElement('li');
                    li.className = 'podcast-item';
                    const img = document.createElement('img');
                    const defaultPlaceholder = `https://placehold.co/50x50/ADD8E6/000000?text=${p.podcast.substring(0,2).toUpperCase()}`;
                    if (p.imageUrl && (p.imageUrl.startsWith('http://') || p.imageUrl.startsWith('https://'))) {
                        img.src = p.imageUrl;
                        img.onerror = () => {
                            img.src = defaultPlaceholder;
                        };
                    } else {
                        img.src = defaultPlaceholder;
                    }
                    img.alt = `Couverture de ${p.podcast}`;
                    li.appendChild(img);
                    
                    const textSpan = document.createElement('span');
                    textSpan.textContent = `${index + 1}. ${p.podcast}: ${p.hours.toFixed(1)}h`;
                    li.appendChild(textSpan);
                    topPodcastsTimeListShort.appendChild(li);
                });

                if (topPodcasts.length > displayLimit) {
                    const otherHours = topPodcasts.slice(displayLimit).reduce((sum, p) => sum + p.hours, 0);
                    const liAutres = document.createElement('li');
                    liAutres.className = 'podcast-item';
                    const imgAutres = document.createElement('img');
                    imgAutres.src = `https://placehold.co/50x50/cccccc/000000?text=Autre`;
                    imgAutres.alt = `Autres podcasts`;
                    liAutres.appendChild(imgAutres);
                    const textSpanAutres = document.createElement('span');
                    textSpanAutres.textContent = `... Autres : ${otherHours.toFixed(1)}h`;
                    liAutres.appendChild(textSpanAutres);
                    topPodcastsTimeListShort.appendChild(liAutres);
                }
                topPodcastsTimeListShort.classList.remove('hidden');
                topPodcastsTimeListFull.classList.add('hidden');
            }

            // Show/hide toggle button
            if (topPodcasts.length <= displayLimit) {
                toggleTopPodcastsButton.classList.add('hidden');
            } else {
                toggleTopPodcastsButton.classList.remove('hidden');
                toggleTopPodcastsButton.textContent = isExpanded ? 'Afficher moins' : 'Afficher plus';
            }
        }


        // --- Filtering and Charting Functions ---
        function populateFilters(data) {
            // Populate Tag Filter
            const tags = new Set();
            data.forEach(item => {
                let tagsRaw = item.tags_column;
                if (tagsRaw && tagsRaw.trim() !== '' && tagsRaw.trim() !== '#root') {
                    // Using \p{L} for any letter, and \p{Lu} for any uppercase letter, with 'u' flag for Unicode
                    const extractedTags = tagsRaw.match(/\p{Lu}[\p{L}]*/gu) || [];
                    extractedTags.forEach(tag => tags.add(tag));
                }
            });
            const sortedTags = Array.from(tags).sort();
            tagFilter.innerHTML = '<option value="">Tous les tags</option>';
            tagFilter.innerHTML += '<option value="Sans Tag">Sans Tag</option>'; // Add "Sans Tag" option
            sortedTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                tagFilter.appendChild(option);
            });


            // Populate allPodcastsTitles for search suggestions
            const podcasts = new Set();
            data.forEach(item => {
                if (item.podcast_title) {
                    podcasts.add(item.podcast_title);
                }
            });
            allPodcastsTitles = Array.from(podcasts).sort();
        }

        function filterPodcastSuggestions() {
            const searchTerm = podcastSearchInput.value.toLowerCase();
            podcastSuggestions.innerHTML = '';
            podcastSearchSelectedIndex = -1; // Reset highlight index

            let filtered;
            if (searchTerm.length === 0) {
                filtered = allPodcastsTitles; // Show all if search term is empty
            } else {
                filtered = allPodcastsTitles.filter(podcast =>
                    podcast.toLowerCase().includes(searchTerm)
                );
            }

            if (filtered.length > 0) {
                podcastSuggestions.classList.remove('hidden');
                filtered.forEach(podcast => {
                    const div = document.createElement('div');
                    div.textContent = podcast;
                    div.className = 'podcast-suggestion-item';
                    div.addEventListener('mousedown', (event) => { // Use mousedown to prevent blur before click
                        event.preventDefault(); // Prevent input from losing focus immediately
                        podcastSearchInput.value = podcast;
                        selectedPodcastHiddenInput.value = podcast; // Store the exact selected value
                        podcastSuggestions.classList.add('hidden');
                        podcastSearchSelectedIndex = -1; // Reset index after selection
                        updateCharts(); // Trigger chart update with exact podcast match
                    });
                    podcastSuggestions.appendChild(div);
                });
            } else {
                podcastSuggestions.classList.add('hidden'); // Hide if no suggestions
            }
        }

        function updateCharts() {
            if (!globalDfHistory) return;

            let filteredData = globalDfHistory;
            const startDateTime = startDateFilter.value ? new Date(startDateFilter.value).getTime() : 0; // Convert to timestamp
            const endDateTime = endDateFilter.value ? new Date(endDateFilter.value).setHours(23, 59, 59, 999) : Infinity; // End of day
            const selectedPodcast = selectedPodcastHiddenInput.value; // Use the value from the hidden input
            const selectedTag = tagFilter.value; // Get selected tag
            const showSansTag = showSansTagCheckbox.checked; // Get state of 'Sans Tag' checkbox

            // Apply date range filter
            if (startDateTime || endDateTime !== Infinity) {
                filteredData = filteredData.filter(item => {
                    if (item.last_played_time > 0) {
                        const itemTime = item.last_played_time;
                        return itemTime >= startDateTime && itemTime <= endDateTime;
                    }
                    return false;
                });
            }

            // Apply podcast filter
            if (selectedPodcast) {
                filteredData = filteredData.filter(item => item.podcast_title === selectedPodcast);
                // Update selected podcast stats display
                const podcastStats = processRawData(filteredData);
                selectedPodcastTitleDisplay.textContent = selectedPodcast;
                selectedPodcastTimeSpan.textContent = `${podcastStats.totalListeningTimeHours.toFixed(1)} heures`;
                selectedPodcastEpisodesSpan.textContent = podcastStats.episodesListened;
                selectedPodcastStatsDiv.classList.remove('hidden');
            } else {
                selectedPodcastStatsDiv.classList.add('hidden');
            }

            // Apply tag filter
            if (selectedTag) {
                filteredData = filteredData.filter(item => {
                    let tagsRaw = item.tags_column;
                    if (!tagsRaw || tagsRaw.trim() === '' || tagsRaw.trim() === '#root') {
                        return selectedTag === 'Sans Tag'; // Match 'Sans Tag' if no tags
                    }
                    tagsRaw = tagsRaw.replace('#root', '').trim();
                    const tags = tagsRaw.match(/\p{Lu}[\p{L}]*/gu) || [];
                    if (selectedTag === 'Sans Tag') {
                        return tags.length === 0; // If 'Sans Tag' selected, return true if no tags found
                    }
                    return tags.includes(selectedTag); // Check if item has the selected tag
                });
            }

            currentProcessedData = processRawData(filteredData); // Update global variable
            updateUIWithStats(currentProcessedData);
            // Re-render both top podcast lists based on the current filter
            renderTopPodcastsTimeList(currentProcessedData.topPodcastsByTime, topPodcastsTimeListFull.classList.contains('expanded'));
            updateMonthlyPodcastList(currentProcessedData.topPodcastsByTime, monthlyPodcastListFull.classList.contains('expanded'));
            renderPodcastStatsList(currentProcessedData.topPodcastsByEpisodeCount, false); // Initial render for podcast stats
            drawCharts(currentProcessedData, startDateTime, endDateTime, selectedPodcast, showSansTag); // Pass showSansTag
            generateWrappedReport(currentProcessedData, startDateTime, endDateTime);
        }

        // Updated function signature and logic
        function updateMonthlyPodcastList(topPodcastsForPeriod, isExpanded) {
            monthlyPodcastListShort.innerHTML = '';
            monthlyPodcastListAll.innerHTML = '';
            
            const start = startDateFilter.value;
            const end = endDateFilter.value;
            let titleText = 'Top Podcasts pour la p√©riode';
            let periodDescription = '';

            if (start && end) {
                periodDescription = ` du ${start} au ${end}`;
            } else if (start) {
                periodDescription = ` √† partir du ${start}`;
            } else if (end) {
                periodDescription = ` jusqu'au ${end}`;
            } else {
                periodDescription = ` (toutes les p√©riodes)`;
            }
            monthlyPodcastDetailTitle.textContent = `${titleText}${periodDescription}`;

            if (topPodcastsForPeriod.length === 0) {
                const li = document.createElement('li');
                li.textContent = "Aucun podcast √©cout√© sur cette p√©riode.";
                monthlyPodcastListShort.appendChild(li);
                toggleMonthlyPodcastsButton.classList.add('hidden');
                monthlyPodcastListFull.classList.add('hidden');
                return;
            }

            const displayLimit = podcastDisplayLimit;

            if (isExpanded) {
                // If expanded, populate full list and hide short list
                topPodcastsForPeriod.forEach((p, index) => {
                    const li = document.createElement('li');
                    li.className = 'podcast-item';
                    const img = document.createElement('img');
                    const defaultPlaceholder = `https://placehold.co/50x50/ADD8E6/000000?text=${p.podcast.substring(0,2).toUpperCase()}`;
                    if (p.imageUrl && (p.imageUrl.startsWith('http://') || p.imageUrl.startsWith('https://'))) {
                        img.src = p.imageUrl;
                        img.onerror = () => { // Fallback if the external image fails to load
                            img.src = defaultPlaceholder;
                        };
                    } else {
                        img.src = defaultPlaceholder;
                    }
                    img.alt = `Couverture de ${p.podcast}`;
                    li.appendChild(img);
                    
                    const textSpan = document.createElement('span');
                    textSpan.textContent = `${index + 1}. ${p.podcast}: ${p.hours.toFixed(1)}h`;
                    li.appendChild(textSpan);
                    monthlyPodcastListAll.appendChild(li);
                });
                monthlyPodcastListShort.classList.add('hidden');
                monthlyPodcastListFull.classList.remove('hidden');
            } else {
                // If collapsed, populate short list (with "Autres" if needed) and hide full list
                topPodcastsForPeriod.slice(0, displayLimit).forEach((p, index) => {
                    const li = document.createElement('li');
                    li.className = 'podcast-item';
                    const img = document.createElement('img');
                    const defaultPlaceholder = `https://placehold.co/50x50/ADD8E6/000000?text=${p.podcast.substring(0,2).toUpperCase()}`;
                    if (p.imageUrl && (p.imageUrl.startsWith('http://') || p.imageUrl.startsWith('https://'))) {
                        img.src = p.imageUrl;
                        img.onerror = () => { // Fallback if the external image fails to load
                            img.src = defaultPlaceholder;
                        };
                    } else {
                        img.src = defaultPlaceholder;
                    }
                    img.alt = `Couverture de ${p.podcast}`;
                    li.appendChild(img);
                    
                    const textSpan = document.createElement('span');
                    textSpan.textContent = `${index + 1}. ${p.podcast}: ${p.hours.toFixed(1)}h`;
                    li.appendChild(textSpan);
                    monthlyPodcastListShort.appendChild(li);
                });

                if (topPodcastsForPeriod.length > displayLimit) {
                    const otherHours = topPodcastsForPeriod.slice(displayLimit).reduce((sum, p) => sum + p.hours, 0);
                    const liAutres = document.createElement('li');
                    liAutres.className = 'podcast-item';
                    const imgAutres = document.createElement('img');
                    imgAutres.src = `https://placehold.co/50x50/cccccc/000000?text=Autre`;
                    imgAutres.alt = `Autres podcasts`;
                    liAutres.appendChild(imgAutres);
                    const textSpanAutres = document.createElement('span');
                    textSpanAutres.textContent = `... Autres : ${otherHours.toFixed(1)}h`;
                    liAutres.appendChild(textSpanAutres);
                    monthlyPodcastListShort.appendChild(liAutres);
                }
                monthlyPodcastListShort.classList.remove('hidden');
                monthlyPodcastListFull.classList.add('hidden');
            }

            // Show/hide toggle button for monthly list
            if (topPodcastsForPeriod.length <= displayLimit) {
                toggleMonthlyPodcastsButton.classList.add('hidden');
            } else {
                toggleMonthlyPodcastsButton.classList.remove('hidden');
                toggleMonthlyPodcastsButton.textContent = isExpanded ? 'Afficher moins' : 'Afficher plus';
            }
        }

        /**
         * Renders the Podcast Stats list, handling "Autres" based on expanded state.
         * @param {Array} topPodcastsByEpisodeCount The full sorted list of top podcasts by episode count.
         * @param {boolean} isExpanded Whether the full list is currently expanded.
         */
        function renderPodcastStatsList(topPodcastsByEpisodeCount, isExpanded) {
            podcastStatsListShort.innerHTML = '';
            podcastStatsListAll.innerHTML = '';

            const displayLimit = podcastDisplayLimit;

            if (isExpanded) {
                // If expanded, populate full list and hide short list
                topPodcastsByEpisodeCount.forEach((p, index) => {
                    const li = document.createElement('li');
                    li.textContent = `${index + 1}. ${p.podcast}: ${p.count} √©pisodes`;
                    podcastStatsListAll.appendChild(li);
                });
                podcastStatsListShort.classList.add('hidden');
                podcastStatsListFull.classList.remove('hidden');
            } else {
                // If collapsed, populate short list (with "Autres" if needed) and hide full list
                topPodcastsByEpisodeCount.slice(0, displayLimit).forEach((p, index) => {
                    const li = document.createElement('li');
                    li.textContent = `${index + 1}. ${p.podcast}: ${p.count} √©pisodes`;
                    podcastStatsListShort.appendChild(li);
                });

                if (topPodcastsByEpisodeCount.length > displayLimit) {
                    const otherEpisodesCount = topPodcastsByEpisodeCount.slice(displayLimit).reduce((sum, p) => sum + p.count, 0);
                    const liAutres = document.createElement('li');
                    liAutres.className = 'podcast-item';
                    const imgAutres = document.createElement('img');
                    imgAutres.src = `https://placehold.co/50x50/cccccc/000000?text=Autre`;
                    imgAutres.alt = `Autres podcasts`;
                    liAutres.appendChild(imgAutres);
                    const textSpanAutres = document.createElement('span');
                    textSpanAutres.textContent = `... Autres : ${otherEpisodesCount} √©pisodes`;
                    liAutres.appendChild(textSpanAutres);
                    podcastStatsListShort.appendChild(liAutres);
                }
                podcastStatsListShort.classList.remove('hidden');
                podcastStatsListFull.classList.add('hidden');
            }

            // Show/hide toggle button
            if (topPodcastsByEpisodeCount.length <= displayLimit) {
                togglePodcastStatsButton.classList.add('hidden');
            } else {
                togglePodcastStatsButton.classList.remove('hidden');
                togglePodcastStatsButton.textContent = isExpanded ? 'Afficher moins' : 'Afficher plus';
            }
        }


        function drawCharts(stats, startDateTime, endDateTime, selectedPodcast, showSansTag) {
            // Destroy existing chart instances to avoid memory leaks and conflicts
            if (monthlyChartInstance) monthlyChartInstance.destroy();
            if (podcastEpisodeCountChartInstance) podcastEpisodeCountChartInstance.destroy();
            if (hourlyChartInstance) hourlyChartInstance.destroy();
            if (dailyChartInstance) dailyChartInstance.destroy();
            if (podcastTimeDistributionChartInstance) podcastTimeDistributionChartInstance.destroy();
            if (tagTimeDistributionChartInstance) tagTimeDistributionChartInstance.destroy(); // Destroy tags chart

            // Determine period info text
            let periodInfoText;
            if (selectedPodcast) {
                periodInfoText = `Donn√©es pour "${selectedPodcast}" `;
            } else {
                periodInfoText = `Donn√©es `;
            }

            if (startDateTime && endDateTime !== Infinity) {
                const startDate = new Date(startDateTime).toLocaleDateString('fr-FR');
                const endDate = new Date(endDateTime).toLocaleDateString('fr-FR');
                periodInfoText += `du ${startDate} au ${endDate}`;
            } else if (startDateTime) {
                const startDate = new Date(startDateTime).toLocaleDateString('fr-FR');
                periodInfoText += `√† partir du ${startDate}`;
            } else if (endDateTime !== Infinity) {
                const endDate = new Date(endDateTime).toLocaleDateString('fr-FR');
                periodInfoText += `jusqu'au ${endDate}`;
            } else {
                periodInfoText = `pour toutes les p√©riodes`;
            }

            // Update chart period info
            monthlyChartPeriodInfo.textContent = periodInfoText;
            podcastTimeDistributionChartPeriodInfo.textContent = periodInfoText;
            tagTimeDistributionChartPeriodInfo.textContent = periodInfoText; // Update for tags chart
            podcastEpisodeCountChartPeriodInfo.textContent = periodInfoText;
            hourlyChartPeriodInfo.textContent = periodInfoText;
            dailyChartPeriodInfo.textContent = periodInfoText;


            // Monthly/Daily/Weekly Chart (Time instead of Count) based on currentPeriodView
            let chartLabels;
            let chartValues;
            let chartTitle;

            if (currentPeriodView === 'month') {
                const monthlyTotalTimeMap = {};
                stats.allHistoryData.forEach(item => {
                    if (item.last_played_time > 0) {
                        const date = new Date(item.last_played_time);
                        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                        monthlyTotalTimeMap[monthKey] = (monthlyTotalTimeMap[monthKey] || 0) + (item.played_duration || 0);
                    }
                });
                const sortedMonthlyTime = Object.entries(monthlyTotalTimeMap)
                    .sort(([monthA], [monthB]) => monthA.localeCompare(monthB));

                chartLabels = sortedMonthlyTime.map(([month]) => month);
                chartValues = sortedMonthlyTime.map(([, ms]) => ms / (1000 * 3600)); // Convert ms to hours
                chartTitle = 'Temps d\'√©coute mensuel (heures)';

            } else if (currentPeriodView === 'week') {
                const weeklyListeningTimeMap = {};
                stats.allHistoryData.forEach(item => {
                    if (item.last_played_time > 0 && item.played_duration > 0) {
                        const date = new Date(item.last_played_time);
                        const weekKey = getISOWeek(date); // Get ISO week (YYYY-WW)
                        weeklyListeningTimeMap[weekKey] = (weeklyListeningTimeMap[weekKey] || 0) + (item.played_duration || 0);
                    }
                });

                const sortedWeeklyData = Object.entries(weeklyListeningTimeMap)
                    .sort(([weekA], [weekB]) => weekA.localeCompare(weekB));

                chartLabels = sortedWeeklyData.map(([week]) => week);
                chartValues = sortedWeeklyData.map(([, ms]) => ms / (1000 * 3600)); // Convert ms to hours
                chartTitle = 'Temps d\'√©coute par semaine (heures)';

            } else if (currentPeriodView === 'day') {
                const dailyListeningTimeForPeriod = {};
                stats.allHistoryData.forEach(item => {
                    if (item.last_played_time > 0) {
                        const date = new Date(item.last_played_time);
                        const dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                        dailyListeningTimeForPeriod[dateKey] = (dailyListeningTimeForPeriod[dateKey] || 0) + (item.played_duration || 0);
                    }
                });

                const sortedDailyData = Object.entries(dailyListeningTimeForPeriod).sort(([dateA], [dateB]) => dateA.localeCompare(dateB));

                chartLabels = sortedDailyData.map(([date]) => date);
                chartValues = sortedDailyData.map(([, ms]) => ms / (1000 * 3600)); // Convert ms to hours
                chartTitle = `Temps d'√©coute quotidien sur la p√©riode (heures)`;
            }


            monthlyChartInstance = new Chart(monthlyCtx, {
                type: 'bar', // Always bar chart for this now
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: 'Heures √©cout√©es',
                        data: chartValues,
                        backgroundColor: '#0e6270', /* New color */
                        borderColor: '#0e6270', /* New color */
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: 'Heures' } }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: chartTitle
                        }
                    }
                }
            });

            // Podcast Episode Count Chart (Horizontal Bar Chart)
            const podcastCounts = {};
            stats.allHistoryData.forEach(item => { // Use allHistoryData from the processed (filtered) data
                if (item.podcast_title && item.played_duration > 0) {
                    podcastCounts[item.podcast_title] = (podcastCounts[item.podcast_title] || 0) + 1;
                }
            });
            const sortedPodcastCounts = Object.entries(podcastCounts).sort(([, a], [, b]) => b - a);
            // Apply podcastDisplayLimit here for the chart
            const limitedPodcastCounts = sortedPodcastCounts.slice(0, podcastDisplayLimit);

            const podcastEpisodeLabels = limitedPodcastCounts.map(([title]) => title);
            const podcastEpisodeValues = limitedPodcastCounts.map(([, count]) => count);

            // Dynamically adjust height for horizontal bar chart
            const barHeight = 40; // Approximate height per bar including padding
            const minChartHeight = 300; // Minimum height for the chart area
            const calculatedHeight = Math.max(minChartHeight, podcastEpisodeLabels.length * barHeight + 100); // +100 for title/padding
            podcastEpisodeCountChartContainer.style.height = `${calculatedHeight}px`;

            podcastEpisodeCountChartInstance = new Chart(podcastEpisodeCountCtx, {
                type: 'bar',
                data: {
                    labels: podcastEpisodeLabels,
                    datasets: [{
                        label: '√âpisodes √©cout√©s',
                        data: podcastEpisodeValues,
                        backgroundColor: '#0e6270', /* New color */
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y', // Make it horizontal
                    scales: {
                        x: { beginAtZero: true, title: { display: true, text: 'Nombre d\'√©pisodes' } },
                        y: { // Ensure labels are fully visible
                            ticks: {
                                autoSkip: false, // Prevent Chart.js from skipping labels
                                // Callback to ensure full labels are shown, Chart.js will adjust width
                                callback: function(value, index, values) {
                                    return this.getLabelForValue(value); 
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false // No legend needed for single dataset horizontal bar chart
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.x !== null) {
                                        label += context.parsed.x;
                                    }
                                    return label;
                                },
                                title: function(context) {
                                    // Show full podcast title in tooltip
                                    return context[0].label;
                                }
                            }
                        }
                    }
                }
            });

            // Podcast Time Distribution Chart (Doughnut Chart)
            const podcastTimeDistributionData = {};
            stats.allHistoryData.forEach(item => {
                if (item.podcast_title && item.played_duration > 0) {
                    podcastTimeDistributionData[item.podcast_title] = (podcastTimeDistributionData[item.podcast_title] || 0) + item.played_duration;
                }
            });

            const sortedPodcastTimeDistribution = Object.entries(podcastTimeDistributionData)
                .sort(([, a], [, b]) => b - a); // Sort by duration in milliseconds

            const timeDistributionLabels = [];
            const timeDistributionValues = [];
            let otherHours = 0;
            // Use podcastDisplayLimit for the doughnut chart as well
            const displayLimitForDoughnut = podcastDisplayLimit; 

            for (let i = 0; i < sortedPodcastTimeDistribution.length; i++) {
                const [podcast, durationMs] = sortedPodcastTimeDistribution[i];
                const hours = durationMs / (1000 * 3600);
                if (i < displayLimitForDoughnut) {
                    timeDistributionLabels.push(podcast);
                    timeDistributionValues.push(hours);
                } else {
                    otherHours += hours;
                }
            }

            if (otherHours > 0) {
                timeDistributionLabels.push('Autres');
                timeDistributionValues.push(otherHours);
            }

            const backgroundColors = [
                '#0e6270', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9933', '#C9CBCE', '#A3CB38', '#5D4037', '#F44336', '#8e44ad', '#27ae60'
            ]; // More colors for variety if many podcasts
            
            podcastTimeDistributionChartInstance = new Chart(podcastTimeDistributionCtx, {
                type: 'doughnut',
                data: {
                    labels: timeDistributionLabels,
                    datasets: [{
                        data: timeDistributionValues,
                        backgroundColor: backgroundColors.slice(0, timeDistributionLabels.length),
                        hoverOffset: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                boxWidth: 20, // Smaller color box to give more space for text
                                font: {
                                    size: 12 // Slightly smaller font for legend if needed
                                },
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        return data.labels.map((label, i) => {
                                            const meta = chart.getDatasetMeta(0);
                                            // Safely access options and provide fallback
                                            const style = (meta.data[i] && meta.data[i].options) ? meta.data[i].options : {};
                                            const fillStyle = style.backgroundColor || '#cccccc'; // Default grey
                                            const strokeStyle = style.borderColor || '#cccccc'; // Default grey

                                            const value = data.datasets[0].data[i];
                                            return {
                                                text: `${label}: ${value.toFixed(1)}h`, // Include value in legend
                                                fillStyle: fillStyle,
                                                strokeStyle: strokeStyle,
                                                lineWidth: style.borderWidth || 1, // Default border width
                                                hidden: isNaN(data.datasets[0].data[i]) || (meta.data[i] ? meta.data[i].hidden : false),
                                                index: i
                                            };
                                        });
                                    }
                                    return [];
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    return `${label}: ${value.toFixed(1)} heures`;
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: 'Distribution du Temps d\'√âcoute par Podcast (en heures)'
                        }
                    }
                }
            });

            // New: Tag Time Distribution Chart (Doughnut Chart)
            const tagDistributionLabels = [];
            const tagDistributionValues = [];
            let otherTagHours = 0;
            const displayLimitForTagDoughnut = podcastDisplayLimit;

            // Iterate directly over the pre-processed stats.tagsListening
            // Filter out 'Sans Tag' if the checkbox is unchecked
            const filteredTags = stats.tagsListening.filter(([tag]) => !(tag === 'Sans Tag' && !showSansTag));

            for (let i = 0; i < filteredTags.length; i++) {
                const [tag, durationMs] = filteredTags[i];
                const hours = durationMs / (1000 * 3600);
                
                if (i < displayLimitForTagDoughnut) {
                    tagDistributionLabels.push(tag);
                    tagDistributionValues.push(hours);
                } else {
                    otherTagHours += hours;
                }
            }

            if (otherTagHours > 0) {
                tagDistributionLabels.push('Autres Tags');
                tagDistributionValues.push(otherTagHours);
            }

            // Reusing backgroundColors, can add more if needed
            tagTimeDistributionChartInstance = new Chart(tagTimeDistributionCtx, {
                type: 'doughnut',
                data: {
                    labels: tagDistributionLabels,
                    datasets: [{
                        data: tagDistributionValues,
                        backgroundColor: backgroundColors.slice(0, tagDistributionLabels.length),
                        hoverOffset: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                boxWidth: 20,
                                font: {
                                    size: 12
                                },
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    if (data.labels.length && data.datasets.length) {
                                        return data.labels.map((label, i) => {
                                            const meta = chart.getDatasetMeta(0);
                                            const style = (meta.data[i] && meta.data[i].options) ? meta.data[i].options : {};
                                            const fillStyle = style.backgroundColor || '#cccccc';
                                            const strokeStyle = style.borderColor || '#cccccc';

                                            const value = data.datasets[0].data[i];
                                            return {
                                                text: `${label}: ${value.toFixed(1)}h`,
                                                fillStyle: fillStyle,
                                                strokeStyle: strokeStyle,
                                                lineWidth: style.borderWidth || 1,
                                                hidden: isNaN(data.datasets[0].data[i]) || (meta.data[i] ? meta.data[i].hidden : false),
                                                index: i
                                            };
                                        });
                                    }
                                    return [];
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    return `${label}: ${value.toFixed(1)} heures`;
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: 'Distribution du Temps d\'√âcoute par Tag (en heures)'
                        }
                    }
                }
            });


            // Hourly Chart
            const hourlyListeningTimeMap = {};
            for (let i = 0; i < 24; i++) hourlyListeningTimeMap[i] = 0; // Initialize all hours with 0 duration
            stats.allHistoryData.forEach(item => {
                if (item.last_played_time > 0 && item.played_duration > 0) {
                    const date = new Date(item.last_played_time);
                    const hour = date.getHours();
                    hourlyListeningTimeMap[hour] = (hourlyListeningTimeMap[hour] || 0) + (item.played_duration || 0);
                }
            });
            const hourlyLabels = Object.keys(hourlyListeningTimeMap).map(hour => `${hour}h`);
            const hourlyValues = Object.values(hourlyListeningTimeMap).map(ms => ms / (1000 * 3600)); // Convert ms to hours

            hourlyChartInstance = new Chart(hourlyCtx, {
                type: 'bar',
                data: {
                    labels: hourlyLabels,
                    datasets: [{
                        label: 'Heures √©cout√©es',
                        data: hourlyValues,
                        backgroundColor: '#f6ad55',
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: 'Heures' } }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Temps d\'√©coute par heure de la journ√©e'
                        }
                    }
                }
            });

            // Daily Chart (Starts Monday)
            const dayNames = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche']; // Order starts Monday
            // Access dailyListening from the stats object
            const dailyValues = stats.dailyListening.map(item => item.count); // Get counts in correct order and convert to hours

            dailyChartInstance = new Chart(dailyCtx, {
                type: 'bar',
                data: {
                    labels: dayNames, // Use the ordered day names
                    datasets: [{
                        label: 'Heures √©cout√©es',
                        data: dailyValues,
                        backgroundColor: '#fc8181',
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: 'Heures' } }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Temps d\'√©coute par jour de la semaine'
                        }
                    }
                }
            });
        }

        // --- Spotify Wrapped inspired report generation ---
        function generateWrappedReport(stats, startDateTime, endDateTime) {
            const totalHours = stats.totalListeningTimeHours.toFixed(1);
            let periodText;
            if (startDateTime && endDateTime !== Infinity) {
                const startDate = new Date(startDateTime).toLocaleDateString('fr-FR');
                const endDate = new Date(endDateTime).toLocaleDateString('fr-FR');
                periodText = `du ${startDate} au ${endDate}`;
            } else if (startDateTime) {
                const startDate = new Date(startDateTime).toLocaleDateString('fr-FR');
                periodText = `√† partir du ${startDate}`;
            } else if (endDateTime !== Infinity) {
                const endDate = new Date(endDateTime).toLocaleDateString('fr-FR');
                periodText = `jusqu'au ${endDate}`;
            } else {
                periodText = `cette ann√©e`; // Default if no dates selected
            }

            const top5Podcasts = stats.topPodcastsByTime.slice(0, 5); // Get top 5 from filtered data

            let message = `üéâ Mon Bilan AntennaPod ${periodText} !\n\n`;
            message += `J'ai √©cout√© des podcasts pendant ${totalHours} heures ${periodText.replace('pour ', '')} ! C'est l'√©quivalent de ${stats.totalListeningTimeDays.toFixed(1)} jours complets üéß.\n\n`;
            
            if (top5Podcasts.length > 0) {
                message += `Mes top 5 podcasts ${periodText.replace('pour ', '')} :\n`;
                top5Podcasts.forEach((p, index) => {
                    // Using a simple emoji for podcast image representation in text export
                    message += `${index + 1}. üéôÔ∏è "${p.podcast}" : ${p.hours.toFixed(1)} heures\n`;
                });
            } else {
                message += `Aucun podcast √©cout√© ${periodText.replace('pour ', '')}.\n`;
            }

            message += `\nJ'ai d√©couvert et √©cout√© ${stats.episodesListened} √©pisodes diff√©rents üìö, avec une dur√©e moyenne par √©coute de ${stats.avgListenDurationMinutes.toFixed(1)} minutes.\n\n`;
            message += `Quelles sont vos stats ? Partagez les v√¥tre ! #AntennaPodStats #PodcastAddict`;

            // Update the div for html2canvas
            wrappedTextContentDiv.textContent = message; 
        }

        // --- CSV Export Function ---
        function exportStatsToCsv(stats) {
            let csvContent = "Statistique,Valeur\n";

            // Overall Stats
            csvContent += `Temps total d'√©coute (heures),${stats.totalListeningTimeHours.toFixed(1)}\n`;
            csvContent += `Temps total d'√©coute (jours),${stats.totalListeningTimeDays.toFixed(1)}\n`;
            csvContent += `√âpisodes √©cout√©s,${stats.episodesListened}\n`;
            csvContent += `√âpisodes termin√©s (>90%),${stats.episodesCompleted}\n`;
            csvContent += `Taux de compl√©tion (%),${stats.completionRate.toFixed(1)}\n`;
            csvContent += `Dur√©e moyenne par √©coute (minutes),${stats.avgListenDurationMinutes.toFixed(1)}\n`;
            csvContent += `Progression moyenne (%),${stats.avgProgressPercent.toFixed(1)}\n`;
            csvContent += "\n";

            // Top Podcasts by Time
            csvContent += "Top Podcasts par temps d'√©coute\n";
            csvContent += "Rang,Podcast,Heures\n";
            stats.topPodcastsByTime.forEach((p, index) => {
                csvContent += `${index + 1},"${p.podcast.replace(/"/g, '""')}",${p.hours.toFixed(1)}\n`;
            });
            csvContent += "\n";

            // Top Podcasts by Episode Count
            csvContent += "Top Podcasts par √©pisodes √©cout√©s\n";
            csvContent += "Rang,Podcast,√âpisodes\n";
            stats.topPodcastsByEpisodeCount.forEach((p, index) => {
                csvContent += `${index + 1},"${p.podcast.replace(/"/g, '""')}",${p.count}\n`;
            });
            csvContent += "\n";

            // Monthly Listening (if applicable, otherwise daily for period)
            csvContent += "√âcoutes par p√©riode\n";
            if (startDateFilter.value || endDateFilter.value) { // Daily data if a period is selected
                csvContent += "Date,Heures\n";
                const dailyData = {};
                stats.allHistoryData.forEach(item => {
                    if (item.last_played_time > 0) {
                        const date = new Date(item.last_played_time);
                        const dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                        dailyData[dateKey] = (dailyData[dateKey] || 0) + (item.played_duration || 0);
                    }
                });
                Object.entries(dailyData).sort(([dateA], [dateB]) => dateA.localeCompare(dateB)).forEach(([date, ms]) => {
                    csvContent += `${date},${(ms / (1000 * 3600)).toFixed(1)}\n`;
                });
            } else { // Monthly data if no period selected
                csvContent += "Mois,Heures\n";
                stats.monthlyListening.forEach(m => {
                    csvContent += `${m.month},${m.count.toFixed(1)}\n`;
                });
            }
            csvContent += "\n";

            // Hourly Listening
            csvContent += "Temps d'√©coute par heure de la journ√©e\n";
            csvContent += "Heure,Heures\n";
            stats.hourlyListening.forEach(h => {
                csvContent += `${h.hour},${h.count.toFixed(1)}\n`;
            });
            csvContent += "\n";

            // Daily Listening
            csvContent += "Temps d'√©coute par jour de la semaine\n";
            csvContent += "Jour,Heures\n";
            stats.dailyListening.forEach(d => {
                csvContent += `${d.day},${d.count.toFixed(1)}\n`;
            });
            csvContent += "\n";

            // Tags Listening
            csvContent += "Distribution du temps d'√©coute par Tag\n";
            csvContent += "Tag,Heures\n";
            stats.tagsListening.forEach(([tag, durationMs]) => {
                csvContent += `"${tag.replace(/"/g, '""')}",${(durationMs / (1000 * 3600)).toFixed(1)}\n`;
            });
            csvContent += "\n";


            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            saveAs(blob, 'AntennaPod_Stats.csv');
            showMessage('success', 'Statistiques export√©es au format CSV !');
        }

        // --- Raw Data CSV Export Function ---
        function exportRawDataToCsv(data) {
            if (!data || data.length === 0) {
                showMessage('error', 'Aucune donn√©e brute √† exporter.');
                return;
            }

            const headers = [
                "media_id", "episode_title", "podcast_title", "played_duration_ms", "duration_ms",
                "position_ms", "last_played_time_timestamp", "last_played_time_date", "pubDate_timestamp", "pubDate_date",
                "podcast_image_url", "tags_column"
            ];
            let csvContent = headers.map(header => `"${header}"`).join(',') + "\n";

            data.forEach(row => {
                const rowData = [
                    row.media_id,
                    `"${(row.episode_title || '').replace(/"/g, '""')}"`,
                    `"${(row.podcast_title || '').replace(/"/g, '""')}"`,
                    row.played_duration,
                    row.duration,
                    row.position,
                    row.last_played_time,
                    row.last_played_time ? new Date(row.last_played_time).toISOString() : '',
                    row.pubDate,
                    row.pubDate ? new Date(row.pubDate).toISOString() : '',
                    `"${(row.podcast_image_url || '').replace(/"/g, '""')}"`,
                    `"${(row.tags_column || '').replace(/"/g, '""')}"`
                ];
                csvContent += rowData.join(',') + "\n";
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            saveAs(blob, 'AntennaPod_Raw_Data.csv');
            showMessage('success', 'Donn√©es brutes export√©es au format CSV !');
        }


        // --- Simulate Python Script Logic with sql.js ---
        // This part requires sql.js library to be loaded.
        // It's a client-side database engine.
        let SQL;
        async function loadSqlJs() {
            try {
                // Ensure Chart.js, JSZip, FileSaver.js, html2canvas are loaded before proceeding
                // These are loaded in the <head> so they should be available.
                // No explicit check needed here for them, but good to be aware.

                const SQL_wasm = await initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.6.2/${file}`
                });
                SQL = SQL_wasm;
                console.log("sql.js charg√© avec succ√®s.");
            } catch (err) { 
                console.error("Erreur lors du chargement de sql.js:", err);
                showMessage('error', 'Impossible de charger la biblioth√®que de base de donn√©es. Veuillez patienter et r√©essayer.');
            }
        }

        // Load sql.js as soon as possible
        loadSqlJs();

        async function processAntennaPodDb(uint8Array) {
            if (!SQL) {
                showMessage('error', 'La biblioth√®que sql.js n\'est pas encore charg√©e. Veuillez patienter et r√©essayer.');
                return null;
            }

            try {
                const db = new SQL.Database(uint8Array);

                // Replicate the SQL query from the Python script
                // Added f.image_url and f.tags to the query
                const query = `
                    SELECT
                        fm.id as media_id,
                        fm.duration,
                        fm.position,
                        fm.played_duration,
                        fm.last_played_time,
                        fm.playback_completion_date,
                        fi.title as episode_title,
                        fi.pubDate,
                        fi.feed as feed_id,
                        f.title as podcast_title,
                        f.author,
                        f.image_url as podcast_image_url,
                        f.tags as tags_column -- Added tags column
                    FROM FeedMedia fm
                    JOIN FeedItems fi ON fm.feeditem = fi.id
                    JOIN Feeds f ON fi.feed = f.id
                    WHERE fm.played_duration > 0 OR fm.last_played_time > 0
                    ORDER BY fm.last_played_time DESC
                `;

                const res = db.exec(query);
                db.close();

                if (res.length === 0) {
                    console.warn("Aucun r√©sultat trouv√© dans la base de donn√©es AntennaPod.");
                    showMessage('info', 'Aucune donn√©e d\'√©coute trouv√©e dans le fichier fourni.');
                    return null;
                }

                const columns = res[0].columns;
                const values = res[0].values;

                // Transform into array of objects (similar to DataFrame rows)
                const dfHistory = values.map(row => {
                    const rowObject = {};
                    columns.forEach((col, index) => {
                        rowObject[col] = row[index];
                    });
                    // Apply encoding fix to relevant string columns
                    if (rowObject.podcast_title) {
                        rowObject.podcast_title = fixEncoding(rowObject.podcast_title);
                    }
                    if (rowObject.episode_title) {
                        rowObject.episode_title = fixEncoding(rowObject.episode_title);
                    }
                    if (rowObject.tags_column) {
                        // console.log("Raw tags_column before fixEncoding:", rowObject.tags_column); // Debugging log
                        rowObject.tags_column = fixEncoding(rowObject.tags_column);
                        // console.log("Fixed tags_column after fixEncoding:", rowObject.tags_column); // Debugging log
                    }
                    return rowObject;
                });

                return processRawData(dfHistory);

            } catch (error) {
                console.error('Erreur lors du traitement de la base de donn√©es SQLite avec sql.js:', error);
                showMessage('error', `Erreur lors de la lecture du fichier .db : ${error.message}. Assurez-vous que c'est un fichier AntennaPod.db valide.`);
                return null;
            }
        }

        // Helper function to process raw data (from sql.js or backend) into desired stats structure
        function processRawData(data) {
            const listenedEpisodes = data.filter(item => item.last_played_time > 0 && item.played_duration > 0);

            if (listenedEpisodes.length === 0) {
                 return {
                    totalListeningTimeHours: 0,
                    totalListeningTimeDays: 0,
                    episodesListened: 0,
                    episodesCompleted: 0,
                    completionRate: 0,
                    avgListenDurationMinutes: 0,
                    avgProgressPercent: 0,
                    topPodcastsByTime: [],
                    topPodcastsByEpisodeCount: [], // Added for new drawer
                    monthlyListening: [],
                    hourlyListening: [],
                    dailyListening: [],
                    tagsListening: [], // New for tags
                    allHistoryData: [] // Return the filtered data as allHistoryData
                };
            }

            // Calculate overall stats
            const totalMs = listenedEpisodes.reduce((sum, item) => sum + (item.played_duration || 0), 0);
            const totalHours = totalMs / (1000 * 3600);
            const totalDays = totalHours / 24;

            const episodesListenedCount = listenedEpisodes.length;

            const completedEpisodes = listenedEpisodes.filter(
                item => item.played_duration > 0 && item.duration > 0 && item.played_duration >= item.duration * 0.9
            );
            const completionRate = episodesListenedCount > 0 ? (completedEpisodes.length / episodesListenedCount) * 100 : 0;

            const activeEpisodesWithDuration = listenedEpisodes.filter(item => item.played_duration > 0);
            const avgDurationMs = activeEpisodesWithDuration.length > 0 ? activeEpisodesWithDuration.reduce((sum, item) => sum + item.played_duration, 0) / activeEpisodesWithDuration.length : 0;
            const avgDurationMinutes = avgDurationMs / (1000 * 60);

            const progressData = listenedEpisodes.filter(item => item.duration > 0 && item.position >= 0);
            // Corrected syntax for reduce callback and initial value
            const avgProgress = progressData.length > 0 ? progressData.reduce((sum, item) => sum + ((item.position / item.duration) * 100), 0) / progressData.length : 0;

            // Top Podcasts by Time (for the current filtered data)
            const timeByPodcast = {};
            const podcastImageUrls = {}; // New map to store image URLs
            listenedEpisodes.forEach(item => {
                if (item.podcast_title) {
                    timeByPodcast[item.podcast_title] = (timeByPodcast[item.podcast_title] || 0) + (item.played_duration || 0);
                    if (item.podcast_image_url) { // Store image URL if available
                        podcastImageUrls[item.podcast_title] = item.podcast_image_url;
                    }
                }
            });
            const topPodcastsByTime = Object.entries(timeByPodcast)
                .sort(([, a], [, b]) => b - a)
                .map(([podcast, ms]) => ({
                    podcast,
                    hours: ms / (1000 * 3600),
                    imageUrl: podcastImageUrls[podcast] || null // Store the actual image URL
                }));

            // Top Podcasts by Episode Count (for the current filtered data)
            const countByPodcast = {};
            listenedEpisodes.forEach(item => {
                if (item.podcast_title) {
                    countByPodcast[item.podcast_title] = (countByPodcast[item.podcast_title] || 0) + 1;
                    // Image URL is already captured in podcastImageUrls map
                }
            });
            const topPodcastsByEpisodeCount = Object.entries(countByPodcast)
                .sort(([, a], [, b]) => b - a)
                .map(([podcast, count]) => ({
                    podcast,
                    count,
                    imageUrl: podcastImageUrls[podcast] || null // Store the actual image URL
                }));


            // Monthly Listening (now calculates time, not count)
            const monthlyListeningMap = {};
            listenedEpisodes.forEach(item => {
                if (item.last_played_time > 0) {
                    const date = new Date(item.last_played_time);
                    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    monthlyListeningMap[monthKey] = (monthlyListeningMap[monthKey] || 0) + (item.played_duration || 0);
                }
            });
            const monthlyListening = Object.entries(monthlyListeningMap)
                .sort(([monthA], [monthB]) => monthA.localeCompare(monthB))
                .map(([month, ms]) => ({ month, count: ms / (1000 * 3600) })); // Convert ms to hours for 'count'


            // Hourly Listening (now calculates time)
            const hourlyListeningMap = {};
            for (let i = 0; i < 24; i++) hourlyListeningMap[i] = 0; // Initialize all hours
            listenedEpisodes.forEach(item => {
                if (item.last_played_time > 0 && item.played_duration > 0) {
                    const date = new Date(item.last_played_time);
                    const hour = date.getHours();
                    hourlyListeningMap[hour] = (hourlyListeningMap[hour] || 0) + (item.played_duration || 0); // Sum played duration
                }
            });
            const hourlyListening = Object.entries(hourlyListeningMap).map(([hour, durationMs]) => ({ hour: parseInt(hour), count: durationMs / (1000 * 3600) })).sort((a, b) => a.hour - b.hour); // Convert to hours


            // Daily Listening (Monday as first day) (now calculates time)
            // Note: getDay() returns 0 for Sunday, 1 for Monday... 6 for Saturday
            const dayNamesOrdered = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];
            const dailyListeningMap = new Map(); 
            // Initialize map with 0 for all days in the desired order
            dayNamesOrdered.forEach(day => dailyListeningMap.set(day, 0)); 

            listenedEpisodes.forEach(item => {
                if (item.last_played_time > 0 && item.played_duration > 0) {
                    const date = new Date(item.last_played_time);
                    let dayOfWeekIndex = date.getDay(); // 0 (Sunday) to 6 (Saturday)
                    // Adjust index to start from Monday (1 becomes 0, 0 becomes 6)
                    dayOfWeekIndex = (dayOfWeekIndex === 0) ? 6 : dayOfWeekIndex - 1;
                    const dayOfWeekName = dayNamesOrdered[dayOfWeekIndex]; // Use dayNamesOrdered array
                    dailyListeningMap.set(dayOfWeekName, (dailyListeningMap.get(dayOfWeekName) || 0) + (item.played_duration || 0)); // Sum played duration
                }
            });
            const dailyListening = Array.from(dailyListeningMap.entries()).map(([day, durationMs]) => ({ day, count: durationMs / (1000 * 3600) })); // Convert to hours

            // New: Tags Listening
            const timeByTag = {};
            listenedEpisodes.forEach(item => {
                let tagsRaw = item.tags_column; // Use the correct column name from SQL query
                
                // If tagsRaw is null, empty, or only contains whitespace/root, assign 'Sans Tag'
                if (!tagsRaw || tagsRaw.trim() === '' || tagsRaw.trim() === '#root') {
                    timeByTag['Sans Tag'] = (timeByTag['Sans Tag'] || 0) + (item.played_duration || 0);
                    return; // Skip further tag processing for this item
                }

                tagsRaw = tagsRaw.replace('#root', '').trim(); // Remove #root and trim whitespace
                
                // Regex to find sequences starting with an uppercase letter followed by any letters
                // This will split "ScienceFiction" into ["Science", "Fiction"]
                // Using \p{L} for any letter, and \p{Lu} for any uppercase letter, with 'u' flag for Unicode
                const tags = tagsRaw.match(/\p{Lu}[\p{L}]*/gu) || [];
                
                if (tags.length === 0) { // If no valid tags found after regex, also put in 'Sans Tag'
                    timeByTag['Sans Tag'] = (timeByTag['Sans Tag'] || 0) + (item.played_duration || 0);
                    return;
                }

                tags.forEach(tag => {
                    if (tag) { // Ensure tag is not empty after regex match
                        timeByTag[tag] = (timeByTag[tag] || 0) + (item.played_duration || 0);
                    }
                });
            });

            const tagsListening = Object.entries(timeByTag)
                .sort(([, a], [, b]) => b - a)
                .filter(([, duration]) => duration > 0); // Filter out tags with 0 duration


            return {
                totalListeningTimeHours: totalHours,
                totalListeningTimeDays: totalDays,
                episodesListened: episodesListenedCount,
                episodesCompleted: completedEpisodes.length,
                completionRate: completionRate,
                avgListenDurationMinutes: avgDurationMinutes,
                avgProgressPercent: avgProgress,
                topPodcastsByTime: topPodcastsByTime, // This now contains all sorted podcasts for the current filter
                topPodcastsByEpisodeCount: topPodcastsByEpisodeCount, // Added for new drawer
                monthlyListening: monthlyListening, // Now contains hours
                hourlyListening: hourlyListening,
                dailyListening: dailyListening,
                tagsListening: tagsListening, // New for tags
                allHistoryData: listenedEpisodes // Return the filtered data as allHistoryData
            };
        }
    </script>
    <!-- Chart.js for visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- JSZip for creating zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <!-- FileSaver.js for saving files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- html2canvas for image export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
